#include <cstdio>
#include <vector>
#define loop(i,n) for(int i = 0;i < (n);i++)
#define range(i,a,b) for(int i = (a);i <= (b);i++)
#define rrep(i,n) for(int i = (n);i >= 0;i--)
#define rran(i,a,b) for(int i = (b);i >= (a);i--)
#define step(i,a,b,d) for(int i = (a);i <= (b); i += d)
#define all(A) A.begin(),A.end()
#define PI acos(-1)
#define pb push_back
#define mp make_pair
#define sz(A) A.size()
#define len(A) A.length()
#define vi vector<int>
#define ll long long
#define pi pair<int,int>
#define point pair<double,double>
#define pl pair<ll,ll>
#define popcnt(x) __builtin_popcount(x)
#define LSOne(x) ((x) & (-(x)))
#define xx first
#define yy second
#define PQ priority_queue
#define print(A,t) cerr << #A << ": "; copy(all(A),ostream_iterator<t>(cerr," " )); cerr << endl
#define prp(p) cerr << "(" << (p).first << " ," << (p).second << ")";
#define prArr(A,n,t)  cerr << #A << ": "; copy(A,A + n,ostream_iterator<t>(cerr," " )); cerr << endl
#define pre() cin.tie(0),cerr.tie(0),ios_base::sync_with_stdio(0)
using namespace std;

int V[10],ans,m,n;
int degree[10][10],dx [] = {-1,1,0,0},dy [] = {0,0,-1,1};
char G[20][20];

inline void mark(int i,int j){
	V[i] |= 1 << j;	
	loop(k,4){
		int nx = i + dx[k],ny = j + dy[k];
		degree[nx][ny] --;	 
	}
}

inline void unmark(int i,int j){
	V[i] ^= 1 << j;	
	loop(k,4){
		int nx = i + dx[k],ny = j + dy[k];
		degree[nx][ny] ++;
	}
}

bool deadend(int i,int j,int & ox,int & oy,int & ready){
	int aretwos = 0; ready = 0;
	int can[4];
	loop(k,4){
		can[k] = 0;
		int nx = i + dx[k],ny = j + dy[k];
		if(nx == 0 || nx == m + 1 || ny == 0 || ny == n + 1) continue;
		if(degree[nx][ny] == 1 && (nx == m && ny == n)) ready = 1;
		if(degree[nx][ny] == 1 && !(nx == m && ny == n) && !((V[nx] >> ny) & 1)) return 1;
		if(degree[nx][ny] == 2 && !(nx == m && ny == n) && !((V[nx] >> ny) & 1)) {
			aretwos ++;
			ox = nx;
			oy = ny;
		}
		can[k] = !((V[nx] >> ny) & 1);
	}
	if(aretwos > 1) return 1;
	if(degree[i][j] == 2 && ((can[0] && can[1]) || (can[2] && can[3]))) return 1;
	return 0;
}

/*void bt(int i,int j,int ctr){
	if(ctr == 1) {ans += (i == m) && (j == n) ; return;}
	if(i == m && j == n) return;
	int ox = -1,oy = -1,ready;	
	if(deadend(i,j,ox,oy,ready)) return;	
	ctr--;	
	mark(i,j);	
	if(ready){
		bt(m,n,ctr);
		return unmark(i,j);
	}
	if(ox != -1){
		bt(ox,oy,ctr);
		return unmark(i,j);
	}
	
	loop(k,4){
		int nx = i + dx[k],ny = j + dy[k];	
		if(V[nx] & (1 << ny)) continue;
		bt(nx,ny,ctr);
	}
	
	unmark(i,j);
}*/

struct state{
	int i,j,ctr,k,done;
public:
	state(){}
	state(int a,int b,int c,int d):i(a),j(b),ctr(c),k(d),done(0){}
};

void bt(int z){
	vector<state> st;
	st.push_back(state(m,1,z,0));
	while(!st.empty()){
		state & u = st.back(); 
		if(u.done) {
			unmark(u.i,u.j);
			st.pop_back();
			continue;
		}
		int i = u.i,j = u.j;
		if(u.k == 0){
			if(ctr == 1) {ans += (i == m) && (j == n) ; st.pop_back(); continue;}
			if(i == m && j == n) {st.pop_back(); continue;}
			int ox = -1,oy = -1,ready;	
			if(deadend(i,j,ox,oy,ready)) {st.pop_back(); continue;}	
			u.ctr --;
			mark(i,j);	
			if(ready){
				u.done = 1;				
				st.pb(state(m,n,u.ctr,0));	//bt(m,n,ctr);
				continue;
			}
			if(ox != -1){
				u.done = 1;
				st.pb(state(ox,oy,u.ctr,0)); //bt(ox,oy,ctr);
				continue;
			}
		}
		int nx = i + dx[u.k],ny = j + dy[u.k];
		u.k++;
		u.done = u.k == 4;
		if(V[nx] & (1 << ny)) continue;
		st.pb(state(nx,ny,u.ctr,0)); // bt(nx,ny,ctr);
	}
}

int main(){
	while(scanf("%d %d",&m,&n) == 2 && m && n){
		int ctr = 0;
		range(i,1,m) scanf("%s",G[i] + 1);		
		range(i,0,m + 1) {
			V[i] = 0;		
			range(j,0,n + 1){
				if(i == 0 || i == m + 1 || j == 0 || j == n + 1 || G[i][j] == '#') V[i] |= 1 << j;
				ctr += !((V[i] >> j) & 1);		
			}
		}
		range(i,1,m) range(j,1,n){
			degree[i][j] = 0;
			loop(k,4) {
				int nx = i + dx[k],ny = j + dy[k];		
				degree[i][j] += !((V[nx] >> ny) & 1);
			}
		}	
		ans = 0;
		bt(ctr);
		printf("%d\n",ans);
	}	
	return 0;
}
